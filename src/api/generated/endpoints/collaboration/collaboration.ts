/**
 * Generated by orval v8.5.0 üç∫
 * Do not edit manually.
 * PegaAPI
 * The Pega API provides a set of built-in REST services for Pega applications. All APIs require authentication. Provide the credentials for a Pega operator in the Authorization header for each request. Pega recommends accessing APIs using TLS 1.2.
 * OpenAPI spec version: v1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateMessageRequest,
  CreateMessageResponse,
  CreateNotificationRequest,
  CreateNotificationResponse,
  DocumentDetailsResponse,
  DocumentsResponse,
  ErrorResponse,
  GetDocumentsParams,
  GetMessagesParams,
  GetSpacesIdPinsParams,
  GetSpacesParams,
  LeaveOrJoinSpaceResponse,
  ListOfMessages,
  NotificationsResponse,
  SpaceDetailsResponse,
  SpacePinsResponse,
  SpacesResponse
} from '../../model';

import { customFetch } from '../../../mutator/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Gets all the documents the authenticated user has access to. Use filterBy parameter to retrieve documents by Name (OperatorID?), creation date etc.
 * @summary Get documents
 */
export type getDocumentsResponse200 = {
  data: DocumentsResponse;
  status: 200;
};

export type getDocumentsResponse401 = {
  data: void;
  status: 401;
};

export type getDocumentsResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getDocumentsResponseSuccess = getDocumentsResponse200 & {
  headers: Headers;
};
export type getDocumentsResponseError = (getDocumentsResponse401 | getDocumentsResponse403) & {
  headers: Headers;
};

export type getDocumentsResponse = getDocumentsResponseSuccess | getDocumentsResponseError;

export const getGetDocumentsUrl = (params?: GetDocumentsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/documents?${stringifiedParams}` : `/documents`;
};

export const getDocuments = async (params?: GetDocumentsParams, options?: RequestInit): Promise<getDocumentsResponse> => {
  return customFetch<getDocumentsResponse>(getGetDocumentsUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetDocumentsQueryKey = (params?: GetDocumentsParams) => {
  return [`/documents`, ...(params ? [params] : [])] as const;
};

export const getGetDocumentsQueryOptions = <TData = Awaited<ReturnType<typeof getDocuments>>, TError = void | ErrorResponse>(
  params?: GetDocumentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocumentsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocuments>>> = ({ signal }) => getDocuments(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof getDocuments>>>;
export type GetDocumentsQueryError = void | ErrorResponse;

export function useGetDocuments<TData = Awaited<ReturnType<typeof getDocuments>>, TError = void | ErrorResponse>(
  params: undefined | GetDocumentsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocuments>>, TError, Awaited<ReturnType<typeof getDocuments>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDocuments<TData = Awaited<ReturnType<typeof getDocuments>>, TError = void | ErrorResponse>(
  params?: GetDocumentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocuments>>, TError, Awaited<ReturnType<typeof getDocuments>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDocuments<TData = Awaited<ReturnType<typeof getDocuments>>, TError = void | ErrorResponse>(
  params?: GetDocumentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get documents
 */

export function useGetDocuments<TData = Awaited<ReturnType<typeof getDocuments>>, TError = void | ErrorResponse>(
  params?: GetDocumentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocuments>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDocumentsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return details of the document for the given document ID‚Äù. Note that for documents created by uploading files, this API will only return the metadata. The uploaded file content will not be returned
 * @summary Get document details
 */
export type getDocumentsIdResponse200 = {
  data: DocumentDetailsResponse;
  status: 200;
};

export type getDocumentsIdResponse401 = {
  data: void;
  status: 401;
};

export type getDocumentsIdResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getDocumentsIdResponse404 = {
  data: void;
  status: 404;
};

export type getDocumentsIdResponseSuccess = getDocumentsIdResponse200 & {
  headers: Headers;
};
export type getDocumentsIdResponseError = (getDocumentsIdResponse401 | getDocumentsIdResponse403 | getDocumentsIdResponse404) & {
  headers: Headers;
};

export type getDocumentsIdResponse = getDocumentsIdResponseSuccess | getDocumentsIdResponseError;

export const getGetDocumentsIdUrl = (id: string) => {
  return `/documents/${id}`;
};

export const getDocumentsId = async (id: string, options?: RequestInit): Promise<getDocumentsIdResponse> => {
  return customFetch<getDocumentsIdResponse>(getGetDocumentsIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetDocumentsIdQueryKey = (id: string) => {
  return [`/documents/${id}`] as const;
};

export const getGetDocumentsIdQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentsId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocumentsIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentsId>>> = ({ signal }) => getDocumentsId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetDocumentsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentsId>>>;
export type GetDocumentsIdQueryError = void | ErrorResponse;

export function useGetDocumentsId<TData = Awaited<ReturnType<typeof getDocumentsId>>, TError = void | ErrorResponse>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, Awaited<ReturnType<typeof getDocumentsId>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDocumentsId<TData = Awaited<ReturnType<typeof getDocumentsId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, Awaited<ReturnType<typeof getDocumentsId>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDocumentsId<TData = Awaited<ReturnType<typeof getDocumentsId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get document details
 */

export function useGetDocumentsId<TData = Awaited<ReturnType<typeof getDocumentsId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDocumentsIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieve messages for a given context
 * @summary Get messages
 */
export type getMessagesResponse200 = {
  data: ListOfMessages;
  status: 200;
};

export type getMessagesResponse401 = {
  data: void;
  status: 401;
};

export type getMessagesResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getMessagesResponseSuccess = getMessagesResponse200 & {
  headers: Headers;
};
export type getMessagesResponseError = (getMessagesResponse401 | getMessagesResponse403) & {
  headers: Headers;
};

export type getMessagesResponse = getMessagesResponseSuccess | getMessagesResponseError;

export const getGetMessagesUrl = (params?: GetMessagesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/messages?${stringifiedParams}` : `/messages`;
};

export const getMessages = async (params?: GetMessagesParams, options?: RequestInit): Promise<getMessagesResponse> => {
  return customFetch<getMessagesResponse>(getGetMessagesUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetMessagesQueryKey = (params?: GetMessagesParams) => {
  return [`/messages`, ...(params ? [params] : [])] as const;
};

export const getGetMessagesQueryOptions = <TData = Awaited<ReturnType<typeof getMessages>>, TError = void | ErrorResponse>(
  params?: GetMessagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMessagesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessages>>> = ({ signal }) => getMessages(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getMessages>>>;
export type GetMessagesQueryError = void | ErrorResponse;

export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = void | ErrorResponse>(
  params: undefined | GetMessagesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMessages>>, TError, Awaited<ReturnType<typeof getMessages>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = void | ErrorResponse>(
  params?: GetMessagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMessages>>, TError, Awaited<ReturnType<typeof getMessages>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = void | ErrorResponse>(
  params?: GetMessagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get messages
 */

export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = void | ErrorResponse>(
  params?: GetMessagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMessagesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a message
 * @summary Create message
 */
export type postMessagesResponse201 = {
  data: CreateMessageResponse;
  status: 201;
};

export type postMessagesResponse400 = {
  data: void;
  status: 400;
};

export type postMessagesResponse401 = {
  data: void;
  status: 401;
};

export type postMessagesResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type postMessagesResponseSuccess = postMessagesResponse201 & {
  headers: Headers;
};
export type postMessagesResponseError = (postMessagesResponse400 | postMessagesResponse401 | postMessagesResponse403) & {
  headers: Headers;
};

export type postMessagesResponse = postMessagesResponseSuccess | postMessagesResponseError;

export const getPostMessagesUrl = () => {
  return `/messages`;
};

export const postMessages = async (createMessageRequest: CreateMessageRequest, options?: RequestInit): Promise<postMessagesResponse> => {
  return customFetch<postMessagesResponse>(getPostMessagesUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createMessageRequest)
  });
};

export const getPostMessagesMutationOptions = <TError = void | ErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postMessages>>, TError, { data: CreateMessageRequest }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postMessages>>, TError, { data: CreateMessageRequest }, TContext> => {
  const mutationKey = ['postMessages'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMessages>>, { data: CreateMessageRequest }> = (props) => {
    const { data } = props ?? {};

    return postMessages(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostMessagesMutationResult = NonNullable<Awaited<ReturnType<typeof postMessages>>>;
export type PostMessagesMutationBody = CreateMessageRequest;
export type PostMessagesMutationError = void | ErrorResponse;

/**
 * @summary Create message
 */
export const usePostMessages = <TError = void | ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postMessages>>, TError, { data: CreateMessageRequest }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postMessages>>, TError, { data: CreateMessageRequest }, TContext> => {
  return useMutation(getPostMessagesMutationOptions(options), queryClient);
};
/**
 * Retrieve notifications
 * @summary Get notifications
 */
export type getNotificationsResponse200 = {
  data: NotificationsResponse;
  status: 200;
};

export type getNotificationsResponse401 = {
  data: void;
  status: 401;
};

export type getNotificationsResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getNotificationsResponseSuccess = getNotificationsResponse200 & {
  headers: Headers;
};
export type getNotificationsResponseError = (getNotificationsResponse401 | getNotificationsResponse403) & {
  headers: Headers;
};

export type getNotificationsResponse = getNotificationsResponseSuccess | getNotificationsResponseError;

export const getGetNotificationsUrl = () => {
  return `/notifications`;
};

export const getNotifications = async (options?: RequestInit): Promise<getNotificationsResponse> => {
  return customFetch<getNotificationsResponse>(getGetNotificationsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetNotificationsQueryKey = () => {
  return [`/notifications`] as const;
};

export const getGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = void | ErrorResponse>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) => getNotifications({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsQueryError = void | ErrorResponse;

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = void | ErrorResponse>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getNotifications>>, TError, Awaited<ReturnType<typeof getNotifications>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = void | ErrorResponse>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getNotifications>>, TError, Awaited<ReturnType<typeof getNotifications>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = void | ErrorResponse>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get notifications
 */

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = void | ErrorResponse>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a notification
 * @summary Create notification
 */
export type postNotificationsResponse201 = {
  data: CreateNotificationResponse;
  status: 201;
};

export type postNotificationsResponse400 = {
  data: void;
  status: 400;
};

export type postNotificationsResponse401 = {
  data: void;
  status: 401;
};

export type postNotificationsResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type postNotificationsResponseSuccess = postNotificationsResponse201 & {
  headers: Headers;
};
export type postNotificationsResponseError = (postNotificationsResponse400 | postNotificationsResponse401 | postNotificationsResponse403) & {
  headers: Headers;
};

export type postNotificationsResponse = postNotificationsResponseSuccess | postNotificationsResponseError;

export const getPostNotificationsUrl = () => {
  return `/notifications`;
};

export const postNotifications = async (
  createNotificationRequest: CreateNotificationRequest,
  options?: RequestInit
): Promise<postNotificationsResponse> => {
  return customFetch<postNotificationsResponse>(getPostNotificationsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createNotificationRequest)
  });
};

export const getPostNotificationsMutationOptions = <TError = void | ErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError, { data: CreateNotificationRequest }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError, { data: CreateNotificationRequest }, TContext> => {
  const mutationKey = ['postNotifications'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postNotifications>>, { data: CreateNotificationRequest }> = (props) => {
    const { data } = props ?? {};

    return postNotifications(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostNotificationsMutationResult = NonNullable<Awaited<ReturnType<typeof postNotifications>>>;
export type PostNotificationsMutationBody = CreateNotificationRequest;
export type PostNotificationsMutationError = void | ErrorResponse;

/**
 * @summary Create notification
 */
export const usePostNotifications = <TError = void | ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError, { data: CreateNotificationRequest }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof postNotifications>>, TError, { data: CreateNotificationRequest }, TContext> => {
  return useMutation(getPostNotificationsMutationOptions(options), queryClient);
};
/**
 * Fetches all the spaces present in the application
 * @summary Get spaces
 */
export type getSpacesResponse200 = {
  data: SpacesResponse;
  status: 200;
};

export type getSpacesResponse401 = {
  data: void;
  status: 401;
};

export type getSpacesResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getSpacesResponseSuccess = getSpacesResponse200 & {
  headers: Headers;
};
export type getSpacesResponseError = (getSpacesResponse401 | getSpacesResponse403) & {
  headers: Headers;
};

export type getSpacesResponse = getSpacesResponseSuccess | getSpacesResponseError;

export const getGetSpacesUrl = (params?: GetSpacesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/spaces?${stringifiedParams}` : `/spaces`;
};

export const getSpaces = async (params?: GetSpacesParams, options?: RequestInit): Promise<getSpacesResponse> => {
  return customFetch<getSpacesResponse>(getGetSpacesUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getGetSpacesQueryKey = (params?: GetSpacesParams) => {
  return [`/spaces`, ...(params ? [params] : [])] as const;
};

export const getGetSpacesQueryOptions = <TData = Awaited<ReturnType<typeof getSpaces>>, TError = void | ErrorResponse>(
  params?: GetSpacesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData>>; request?: SecondParameter<typeof customFetch> }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpacesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaces>>> = ({ signal }) => getSpaces(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetSpacesQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaces>>>;
export type GetSpacesQueryError = void | ErrorResponse;

export function useGetSpaces<TData = Awaited<ReturnType<typeof getSpaces>>, TError = void | ErrorResponse>(
  params: undefined | GetSpacesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSpaces>>, TError, Awaited<ReturnType<typeof getSpaces>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpaces<TData = Awaited<ReturnType<typeof getSpaces>>, TError = void | ErrorResponse>(
  params?: GetSpacesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSpaces>>, TError, Awaited<ReturnType<typeof getSpaces>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpaces<TData = Awaited<ReturnType<typeof getSpaces>>, TError = void | ErrorResponse>(
  params?: GetSpacesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData>>; request?: SecondParameter<typeof customFetch> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get spaces
 */

export function useGetSpaces<TData = Awaited<ReturnType<typeof getSpaces>>, TError = void | ErrorResponse>(
  params?: GetSpacesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaces>>, TError, TData>>; request?: SecondParameter<typeof customFetch> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSpacesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get space details
 * @summary Get space details
 */
export type getSpacesIdResponse200 = {
  data: SpaceDetailsResponse;
  status: 200;
};

export type getSpacesIdResponse401 = {
  data: void;
  status: 401;
};

export type getSpacesIdResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getSpacesIdResponse404 = {
  data: void;
  status: 404;
};

export type getSpacesIdResponseSuccess = getSpacesIdResponse200 & {
  headers: Headers;
};
export type getSpacesIdResponseError = (getSpacesIdResponse401 | getSpacesIdResponse403 | getSpacesIdResponse404) & {
  headers: Headers;
};

export type getSpacesIdResponse = getSpacesIdResponseSuccess | getSpacesIdResponseError;

export const getGetSpacesIdUrl = (id: string) => {
  return `/spaces/${id}`;
};

export const getSpacesId = async (id: string, options?: RequestInit): Promise<getSpacesIdResponse> => {
  return customFetch<getSpacesIdResponse>(getGetSpacesIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetSpacesIdQueryKey = (id: string) => {
  return [`/spaces/${id}`] as const;
};

export const getGetSpacesIdQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpacesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesId>>> = ({ signal }) => getSpacesId(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetSpacesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesId>>>;
export type GetSpacesIdQueryError = void | ErrorResponse;

export function useGetSpacesId<TData = Awaited<ReturnType<typeof getSpacesId>>, TError = void | ErrorResponse>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, Awaited<ReturnType<typeof getSpacesId>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpacesId<TData = Awaited<ReturnType<typeof getSpacesId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, Awaited<ReturnType<typeof getSpacesId>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpacesId<TData = Awaited<ReturnType<typeof getSpacesId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get space details
 */

export function useGetSpacesId<TData = Awaited<ReturnType<typeof getSpacesId>>, TError = void | ErrorResponse>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSpacesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Join space
 * @summary Join space
 */
export type putSpacesIdJoinResponse201 = {
  data: LeaveOrJoinSpaceResponse;
  status: 201;
};

export type putSpacesIdJoinResponse401 = {
  data: void;
  status: 401;
};

export type putSpacesIdJoinResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type putSpacesIdJoinResponse404 = {
  data: void;
  status: 404;
};

export type putSpacesIdJoinResponseSuccess = putSpacesIdJoinResponse201 & {
  headers: Headers;
};
export type putSpacesIdJoinResponseError = (putSpacesIdJoinResponse401 | putSpacesIdJoinResponse403 | putSpacesIdJoinResponse404) & {
  headers: Headers;
};

export type putSpacesIdJoinResponse = putSpacesIdJoinResponseSuccess | putSpacesIdJoinResponseError;

export const getPutSpacesIdJoinUrl = (id: string) => {
  return `/spaces/${id}/join`;
};

export const putSpacesIdJoin = async (id: string, options?: RequestInit): Promise<putSpacesIdJoinResponse> => {
  return customFetch<putSpacesIdJoinResponse>(getPutSpacesIdJoinUrl(id), {
    ...options,
    method: 'PUT'
  });
};

export const getPutSpacesIdJoinMutationOptions = <TError = void | ErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdJoin>>, TError, { id: string }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdJoin>>, TError, { id: string }, TContext> => {
  const mutationKey = ['putSpacesIdJoin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof putSpacesIdJoin>>, { id: string }> = (props) => {
    const { id } = props ?? {};

    return putSpacesIdJoin(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutSpacesIdJoinMutationResult = NonNullable<Awaited<ReturnType<typeof putSpacesIdJoin>>>;

export type PutSpacesIdJoinMutationError = void | ErrorResponse;

/**
 * @summary Join space
 */
export const usePutSpacesIdJoin = <TError = void | ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdJoin>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof putSpacesIdJoin>>, TError, { id: string }, TContext> => {
  return useMutation(getPutSpacesIdJoinMutationOptions(options), queryClient);
};
/**
 * Leave space
 * @summary Leave space
 */
export type putSpacesIdLeaveResponse201 = {
  data: LeaveOrJoinSpaceResponse;
  status: 201;
};

export type putSpacesIdLeaveResponse401 = {
  data: void;
  status: 401;
};

export type putSpacesIdLeaveResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type putSpacesIdLeaveResponse404 = {
  data: void;
  status: 404;
};

export type putSpacesIdLeaveResponseSuccess = putSpacesIdLeaveResponse201 & {
  headers: Headers;
};
export type putSpacesIdLeaveResponseError = (putSpacesIdLeaveResponse401 | putSpacesIdLeaveResponse403 | putSpacesIdLeaveResponse404) & {
  headers: Headers;
};

export type putSpacesIdLeaveResponse = putSpacesIdLeaveResponseSuccess | putSpacesIdLeaveResponseError;

export const getPutSpacesIdLeaveUrl = (id: string) => {
  return `/spaces/${id}/leave`;
};

export const putSpacesIdLeave = async (id: string, options?: RequestInit): Promise<putSpacesIdLeaveResponse> => {
  return customFetch<putSpacesIdLeaveResponse>(getPutSpacesIdLeaveUrl(id), {
    ...options,
    method: 'PUT'
  });
};

export const getPutSpacesIdLeaveMutationOptions = <TError = void | ErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdLeave>>, TError, { id: string }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdLeave>>, TError, { id: string }, TContext> => {
  const mutationKey = ['putSpacesIdLeave'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof putSpacesIdLeave>>, { id: string }> = (props) => {
    const { id } = props ?? {};

    return putSpacesIdLeave(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutSpacesIdLeaveMutationResult = NonNullable<Awaited<ReturnType<typeof putSpacesIdLeave>>>;

export type PutSpacesIdLeaveMutationError = void | ErrorResponse;

/**
 * @summary Leave space
 */
export const usePutSpacesIdLeave = <TError = void | ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof putSpacesIdLeave>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof putSpacesIdLeave>>, TError, { id: string }, TContext> => {
  return useMutation(getPutSpacesIdLeaveMutationOptions(options), queryClient);
};
/**
 * Get pins for the given space
 * @summary Get pins for the given space
 */
export type getSpacesIdPinsResponse200 = {
  data: SpacePinsResponse;
  status: 200;
};

export type getSpacesIdPinsResponse401 = {
  data: void;
  status: 401;
};

export type getSpacesIdPinsResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type getSpacesIdPinsResponse404 = {
  data: void;
  status: 404;
};

export type getSpacesIdPinsResponseSuccess = getSpacesIdPinsResponse200 & {
  headers: Headers;
};
export type getSpacesIdPinsResponseError = (getSpacesIdPinsResponse401 | getSpacesIdPinsResponse403 | getSpacesIdPinsResponse404) & {
  headers: Headers;
};

export type getSpacesIdPinsResponse = getSpacesIdPinsResponseSuccess | getSpacesIdPinsResponseError;

export const getGetSpacesIdPinsUrl = (id: string, params?: GetSpacesIdPinsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/spaces/${id}/pins?${stringifiedParams}` : `/spaces/${id}/pins`;
};

export const getSpacesIdPins = async (id: string, params?: GetSpacesIdPinsParams, options?: RequestInit): Promise<getSpacesIdPinsResponse> => {
  return customFetch<getSpacesIdPinsResponse>(getGetSpacesIdPinsUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

export const getGetSpacesIdPinsQueryKey = (id: string, params?: GetSpacesIdPinsParams) => {
  return [`/spaces/${id}/pins`, ...(params ? [params] : [])] as const;
};

export const getGetSpacesIdPinsQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesIdPins>>, TError = void | ErrorResponse>(
  id: string,
  params?: GetSpacesIdPinsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpacesIdPinsQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesIdPins>>> = ({ signal }) =>
    getSpacesIdPins(id, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetSpacesIdPinsQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesIdPins>>>;
export type GetSpacesIdPinsQueryError = void | ErrorResponse;

export function useGetSpacesIdPins<TData = Awaited<ReturnType<typeof getSpacesIdPins>>, TError = void | ErrorResponse>(
  id: string,
  params: undefined | GetSpacesIdPinsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, Awaited<ReturnType<typeof getSpacesIdPins>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpacesIdPins<TData = Awaited<ReturnType<typeof getSpacesIdPins>>, TError = void | ErrorResponse>(
  id: string,
  params?: GetSpacesIdPinsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, Awaited<ReturnType<typeof getSpacesIdPins>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSpacesIdPins<TData = Awaited<ReturnType<typeof getSpacesIdPins>>, TError = void | ErrorResponse>(
  id: string,
  params?: GetSpacesIdPinsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get pins for the given space
 */

export function useGetSpacesIdPins<TData = Awaited<ReturnType<typeof getSpacesIdPins>>, TError = void | ErrorResponse>(
  id: string,
  params?: GetSpacesIdPinsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesIdPins>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSpacesIdPinsQueryOptions(id, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
