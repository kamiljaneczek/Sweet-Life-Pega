/**
 * Generated by orval v8.5.0 üç∫
 * Do not edit manually.
 * PegaAPI
 * The Pega API provides a set of built-in REST services for Pega applications. All APIs require authentication. Provide the credentials for a Pega operator in the Authorization header for each request. Pega recommends accessing APIs using TLS 1.2.
 * OpenAPI spec version: v1
 */
import { useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customFetch } from '../../../mutator/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Gets the contents of a data view given its name and parameters.
Parameters are passed in as query string parameters. For example, if you have a data view called D_Customer with parameters "ID" and "Company" you could access the data view with the URL https://myco.org/prweb/api/v1/data/D_Customer?ID=1&Company=MyCo.
"Try it out" note: When testing with "try it out" below you cannot enter values for data view parameters to use as part of the test. This means only data views without required parameters can be tested below.
 * @summary Get data view contents
 */
export type getDataPageResponse401 = {
  data: void;
  status: 401;
};

export type getDataPageResponse403 = {
  data: Blob;
  status: 403;
};

export type getDataPageResponse404 = {
  data: Blob;
  status: 404;
};
export type getDataPageResponseError = (getDataPageResponse401 | getDataPageResponse403 | getDataPageResponse404) & {
  headers: Headers;
};

export type getDataPageResponse = getDataPageResponseError;

export const getGetDataPageUrl = (id: string) => {
  return `/data/${id}`;
};

export const getDataPage = async (id: string, options?: RequestInit): Promise<getDataPageResponse> => {
  return customFetch<getDataPageResponse>(getGetDataPageUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetDataPageQueryKey = (id: string) => {
  return [`/data/${id}`] as const;
};

export const getGetDataPageQueryOptions = <TData = Awaited<ReturnType<typeof getDataPage>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDataPageQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataPage>>> = ({ signal }) => getDataPage(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetDataPageQueryResult = NonNullable<Awaited<ReturnType<typeof getDataPage>>>;
export type GetDataPageQueryError = void | Blob;

export function useGetDataPage<TData = Awaited<ReturnType<typeof getDataPage>>, TError = void | Blob>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDataPage>>, TError, Awaited<ReturnType<typeof getDataPage>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDataPage<TData = Awaited<ReturnType<typeof getDataPage>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDataPage>>, TError, Awaited<ReturnType<typeof getDataPage>>>, 'initialData'>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDataPage<TData = Awaited<ReturnType<typeof getDataPage>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get data view contents
 */

export function useGetDataPage<TData = Awaited<ReturnType<typeof getDataPage>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDataPageQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Gets the metadata of a data view given its name.
 * @summary Get data view metadata
 */
export type getDataPageMetadataResponse200 = {
  data: Blob;
  status: 200;
};

export type getDataPageMetadataResponse401 = {
  data: void;
  status: 401;
};

export type getDataPageMetadataResponse403 = {
  data: Blob;
  status: 403;
};

export type getDataPageMetadataResponse404 = {
  data: Blob;
  status: 404;
};

export type getDataPageMetadataResponseSuccess = getDataPageMetadataResponse200 & {
  headers: Headers;
};
export type getDataPageMetadataResponseError = (getDataPageMetadataResponse401 | getDataPageMetadataResponse403 | getDataPageMetadataResponse404) & {
  headers: Headers;
};

export type getDataPageMetadataResponse = getDataPageMetadataResponseSuccess | getDataPageMetadataResponseError;

export const getGetDataPageMetadataUrl = (id: string) => {
  return `/data/${id}/metadata`;
};

export const getDataPageMetadata = async (id: string, options?: RequestInit): Promise<getDataPageMetadataResponse> => {
  return customFetch<getDataPageMetadataResponse>(getGetDataPageMetadataUrl(id), {
    ...options,
    method: 'GET'
  });
};

export const getGetDataPageMetadataQueryKey = (id: string) => {
  return [`/data/${id}/metadata`] as const;
};

export const getGetDataPageMetadataQueryOptions = <TData = Awaited<ReturnType<typeof getDataPageMetadata>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDataPageMetadataQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataPageMetadata>>> = ({ signal }) =>
    getDataPageMetadata(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetDataPageMetadataQueryResult = NonNullable<Awaited<ReturnType<typeof getDataPageMetadata>>>;
export type GetDataPageMetadataQueryError = void | Blob;

export function useGetDataPageMetadata<TData = Awaited<ReturnType<typeof getDataPageMetadata>>, TError = void | Blob>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, Awaited<ReturnType<typeof getDataPageMetadata>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDataPageMetadata<TData = Awaited<ReturnType<typeof getDataPageMetadata>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, Awaited<ReturnType<typeof getDataPageMetadata>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDataPageMetadata<TData = Awaited<ReturnType<typeof getDataPageMetadata>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get data view metadata
 */

export function useGetDataPageMetadata<TData = Awaited<ReturnType<typeof getDataPageMetadata>>, TError = void | Blob>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataPageMetadata>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDataPageMetadataQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
